import math
import os
import numpy as np
import pandas as pd
from tqdm import tqdm
from ast import literal_eval
from Lineage_Library import Cell, Library
from functions import read_multiframe_tiff, extract_cells, calculate_iou


# USER INPUTS #################################################################

# Path for original cell images as .tif file
imgs_path = 'data\RFP_GFP_MIDDLE5\RFP_GFP_MIDDLE5.tif'

# Path for cell masks ouput by Cellpose as .tif file
masks_path = "data\RFP_GFP_MIDDLE5\seg_RFP_GFP_MIDDLE5.tif"

# Path for segmentation information generated by AREA as .csv file
info_path = "data\RFP_GFP_MIDDLE5\EXP_MIDDLE5_1.csv"

# Channel name to use visual feature extraction on, as a string
channel = 'RFP'

# Numerical value for max radius of which cells need for identificaiton across frames
search_radius = 100

###############################################################################

### PART 1: Import data and Preprocessing

# TODO: Check that data exists in the correct format ###############

# Import data
masks = read_multiframe_tiff(masks_path)
info_df = pd.read_csv(info_path)

# Pre-processing
info_df = info_df[info_df['Channel'] == channel]
df = info_df[['Frame', 'ROI']]
df[['x', 'y']] = info_df['Centroid'].str.strip('()').str.split(', ', expand=True).astype(float)


# Extract cells and generate cell img database. (img name e.g., 'frame_0_cell_1')
dir_path, base_name = os.path.split(imgs_path)
cells_path = os.path.join(dir_path, os.path.splitext(base_name)[0] + "_cells.hdf5")
# extract_cells(imgs_path, masks_path, cells_path, channel)
del dir_path, base_name
print(cells_path)


# TODO: train or import model.h5 
breakpoint

### PART 2: Frame-by-frame Pairwise Cell Labeling

# Initialize library for tracking lineages
lib = Library(masks[0], df)

prev_mask = masks[0]
# for i, mask in tqdm(enumerate(masks[1:]), total=len(masks)-1, leave=False,
#                       desc="Processing Frames", unit="frame", ncols=80):
for i, mask in enumerate(masks[1:]):
    current_frame = i + 1;
    temp_df = df[df['Frame'] == current_frame]

    for recent_cell in lib.all_recent():
        prev_mask = masks[recent_cell['frame']]
        
        scores = []
        for new_cell in np.unique(mask)[1:]:
            if new_cell != 0:
                # only proceed if the x and y are within certain distance
                x_new, y_new = temp_df[temp_df['ROI']==(new_cell-1)].iloc[0][['x', 'y']]
                distance = math.sqrt((x_new - recent_cell['x'])**2 + (y_new - recent_cell['y'])**2)
                if distance < search_radius:
                    # calculate IoU score
                    iou_score = calculate_iou(recent_cell['cell_id'], prev_mask, new_cell, mask)
                    if iou_score > 0: 
                        scores.append({
                            'next_cell_id': new_cell,
                            'next_cell_x': x_new,
                            'next_cell_y': y_new,
                            'lineage_id': recent_cell['lineage_id'],
                            'iou_score': iou_score,
                            'distance': distance
                        })
        
        if (len(scores) == 1) and (scores[0]['iou_score'] > 0.3):
            print(f"MATCH: Cell #{recent_cell['cell_id']} found in frame {current_frame}.")
            lib.add_cell(Cell(
                cell_id = scores[0]['next_cell_id'],
                lineage_id = recent_cell['lineage_id'],
                frame = current_frame,
                x = scores[0]['next_cell_x'],
                y = scores[0]['next_cell_y']
            ))
        elif (len(scores) > 1):
            print(f"MATCH: Found {len(scores)} potential cells for cell #{recent_cell['cell_id']}.")
            pass
        else:
            print(f"NO MATCH: No potential cells found for cell #{recent_cell['cell_id']}.")
            pass

 # before assigning a cell, call a function that checks to see if the desired cell has already been assigned       
        