'''
Cell Lineage Identification Script

This script is designed to perform cell identification tracking using a combination of
spatial, visual, and morphological features. It imports raw data, preprocesses the data,
trains an autoencoder for visual feature extraction, and then performs frame-by-frame
pairwise cell labeling to identify and track cells across frames.

Inputs:
    Original cell images as .tif file
    Cell masks output by Cellpose as .tif file
    Segmentation information generated by AREA as .csv file
    Channel name for visual feature extraction
    Maximum search radius for cell identification across frames

Outputs:
    Extracted single cell images stored in an HDF5 file
    Trained autoencoder model saved as an .h5 file
    Lineage tracking information printed to the console

Dependencies:
    os
    math
    h5py
    numpy
    pandas
    tqdm
    sklearn
    tensorflow
    scipy
    lineage_managment
    img_processing
    cell_similarity_metrics

@author: Shani Zuniga
'''
import os
import math

import h5py
import numpy as np
import pandas as pd

from tqdm import tqdm
from sklearn.model_selection import train_test_split
from tensorflow import keras
from keras.callbacks import EarlyStopping
from scipy.spatial.distance import cdist

from utils.lineage_management import Library
from utils.img_processing import read_multiframe_tiff, extract_cells
from utils.cell_similarity_metrics import calculate_iou, cosine_similarity

# USER INPUTS #################################################################

# Path for original cell images as .tif file
imgs_path = 'test_data\RFP_GFP_MIDDLE5\RFP_GFP_MIDDLE5.tif'

# Path for cell masks ouput by Cellpose as .tif file
masks_path = "test_data\RFP_GFP_MIDDLE5\seg_RFP_GFP_MIDDLE5.tif"

# Path for segmentation information generated by AREA as .csv file
info_path = "test_data\RFP_GFP_MIDDLE5\EXP_MIDDLE5_1.csv"

# Channel name to use visual feature extraction on, as a string
channel = 'RFP'

# Numerical value for max distance of which cells need for consideration
search_radius = 100


### PART 1: Import data and Preprocessing######################################
print("IMPORTING DATA AND PREPROCESSING...")

# TODO: Check that data exists in the correct format ###############

# 1. Import data
masks = read_multiframe_tiff(masks_path)
info_df = pd.read_csv(info_path)
dir_path, base_name = os.path.split(imgs_path)

# 2. Pre-processing informational data (channel, centroid extraction)
info_df = info_df[info_df['Channel'] == channel]
df = info_df[['Frame', 'ROI']].copy()
centroids = (
    info_df['Centroid']
    .str.strip('()')
    .str.split(', ', expand=True)
    .astype(float)
    )
df[['x', 'y']] = centroids

# 3. Extract cells and generate cell img database. (img name e.g., 'frame_0_cell_1')
cells_path = os.path.join(dir_path, os.path.splitext(base_name)[0] + "_cells.hdf5")
extract_cells(imgs_path, masks_path, cells_path, channel)

img_dict = {}
with h5py.File(cells_path, 'r') as hf:
    for key in hf.keys():
        img_dict[key] = hf[key][()]

x_train = np.array(list(img_dict.values()))
x_train = x_train.reshape(x_train.shape[0], 28, 28, 1)
x_train, x_test = train_test_split(x_train, test_size=0.2, random_state=42)

early_stop = EarlyStopping(monitor='val_loss', patience=5)

print(f"training dataset shape: {x_train.shape}")
print(f"testing dataset shape: {x_test.shape}")

# 4. Train autoencoder on the single cell images
encoder = keras.models.Sequential([
    keras.layers.Flatten(input_shape=[28, 28]),
    keras.layers.Dense(100, activation="relu"),
    keras.layers.Dense(30, activation="relu"),
    ])
decoder = keras.models.Sequential([
    keras.layers.Dense(100, activation="relu", input_shape=[30]),
    keras.layers.Dense(28 * 28, activation="sigmoid"),
    keras.layers.Reshape([28, 28])
    ])
autoencoder = keras.models.Sequential([encoder, decoder])
autoencoder.compile(loss="binary_crossentropy",
                optimizer='adam')
autoencoder.fit(x_train, x_train, epochs=300, validation_data=[x_test, x_test],
                callbacks=[early_stop], verbose=0) 
del x_train, x_test

print("PREPROCESSING COMPLETE.")


### PART 2: Frame-by-frame Pairwise Cell Labeling##############################
print("INITIATING FRAME-BY-FRAME CELL IDENTIFICATION...")

# Initialize library for tracking lineages
lib = Library(masks[0], df)

for i, mask in tqdm(enumerate(masks[1:]), total=len(masks)-1, leave=False,
                    desc="Processing Frames", unit="frame", ncols=80):
    current_frame = i + 1
    temp_df = df[df['Frame'] == current_frame]

    scores = []
    for recent_cell in lib.all_recent():
        curr_mask = masks[current_frame]
        prev_mask = masks[recent_cell['frame']]

        key = f'frame_{recent_cell["frame"]}_cell_{recent_cell["cell_id"]}'
        cell_img = img_dict[key].reshape(1, 28, 28, 1)
        recent_vec = encoder.predict(cell_img, verbose=0)

        new_cells = np.unique(curr_mask)[1:]
        new_cells = new_cells[new_cells != 0]

        recent_cell_coords = np.array([recent_cell['x'], recent_cell['y']])
        new_cell_coords = (
            temp_df[temp_df['ROI'].isin(new_cells - 1)][['x', 'y']].to_numpy()
            )
        distances = cdist(recent_cell_coords.reshape(1, -1), new_cell_coords)[0]
        new_cells = new_cells[distances < search_radius]

        for new_cell in new_cells:
            if lib.is_recent_cell(current_frame, new_cell) == -1:
                x_new, y_new = (
                    temp_df[temp_df['ROI'] == (new_cell - 1)].iloc[0][['x', 'y']]
                    )
                
                iou_score = calculate_iou(recent_cell['cell_id'], prev_mask, 
                                        new_cell, mask)

                if iou_score > 0:
                    key = f'frame_{current_frame}_cell_{new_cell}'
                    cell_img = img_dict[key].reshape(1, 28, 28, 1)
                    new_vec = encoder.predict(cell_img, verbose=0)
                    visual_score = cosine_similarity(recent_vec, new_vec)

                    distance = math.sqrt(
                        (x_new - recent_cell['x'])**2 +
                        (y_new - recent_cell['y'])**2
                        )

                    scores.append({
                        'next_cell_id': new_cell,
                        'next_cell_x': x_new,
                        'next_cell_y': y_new,
                        'lineage_id': recent_cell['lineage_id'],
                        'iou_score': iou_score,
                        'visual_score': visual_score,
                        'distance': distance
                        })

    lib.identify_cells(current_frame, scores)

print("CELL IDENTIFICATION COMPLETE.")


# from pandasgui import show
# show(lib.to_dataframe())