'''
Cell Lineage Identification Script

This script is designed to perform cell identification tracking using a combination of
spatial, visual, and morphological features. It imports raw data, preprocesses the data,
trains an autoencoder for visual feature extraction, and then performs frame-by-frame
pairwise cell labeling to identify and track cells across frames.

Inputs:
    Original cell images as .tif file
    Cell masks output by Cellpose as .tif file
    Segmentation information generated by AREA as .csv file
    Channel name for visual feature extraction
    Maximum search radius for cell identification across frames
    Whether to import preprocessing steps

Outputs:
    Information dataframe with cell labels as .csv file
    Trained autoencoder model saved as an .h5 file
    Encoded cell images saved as .npz file

Dependencies:
    os
    math
    numpy
    pandas
    tqdm
    sklearn
    tensorflow
    scipy
    lineage_managment
    img_processing
    cell_similarity_metrics

@author: Shani Zuniga
'''
import os
import sys
import math

import numpy as np
import pandas as pd

from tqdm import tqdm
from sklearn.model_selection import train_test_split
from tensorflow import get_logger, keras
from keras.callbacks import EarlyStopping
from scipy.spatial.distance import cdist

from utils.lineage_management import Library
from utils.img_processing import read_multiframe_tif, extract_cells
from utils.cell_similarity_metrics import calculate_iou, cosine_similarity

get_logger().setLevel('ERROR')
# USER INPUTS #################################################################

# Path for original cell images as .tif file
imgs_path = "data\RFP_GFP_MIDDLE5\RFP_GFP_MIDDLE5.tif"

# Path for cell masks ouput by Cellpose as .tif file
masks_path = "data\RFP_GFP_MIDDLE5\seg_RFP_GFP_MIDDLE5.tif"

# Path for segmentation information generated by AREA as .csv file
info_path = "data\RFP_GFP_MIDDLE5\EXP_MIDDLE5_1.csv"

# Channel name to use visual feature extraction on, as a string
channel = "RFP"

# Numerical value for max distance of which cells need for consideration
search_radius = 50

# Whether preprocessing steps have already been completed, else will be saved
import_preprocessing = True

### PART 1: Import data and Preprocessing######################################
print("IMPORTING DATA AND PREPROCESSING...")

# 1. Import data and check that paths are valid
if (os.path.exists(imgs_path) and os.path.exists(masks_path) and 
    os.path.exists(info_path)):
    masks = read_multiframe_tif(masks_path)
    info_df = pd.read_csv(info_path)
else:
    print('ERROR: Input data not found. Check path names.')
    sys.exit(0)

# 2. Pre-processing informational data (channel, centroid extraction)
df = info_df[['Frame', 'ROI']].copy()
df = df[info_df['Channel'] == channel]
centroids = (
    info_df['Centroid']
    .str.strip('()')
    .str.split(', ', expand=True)
    .astype(float)
    )
df[['x', 'y']] = centroids

# 3. Import or generate encoded cell vectors
folder_path, file_name_with_ext = os.path.split(imgs_path)
file_name, file_ext = os.path.splitext(file_name_with_ext)

new_folder_path = os.path.join(folder_path, file_name + '_FLUORA')
vectors_path = os.path.join(new_folder_path, 'encoded_cells.npz')
encoder_path = os.path.join(new_folder_path, 'cell_encoder.h5')

if import_preprocessing and (os.path.exists(new_folder_path)):
    if os.path.exists(vectors_path):
        pass
    else:
        print('ERROR: Preprocessed data not found.')
        sys.exit(0)
    with np.load(vectors_path) as data_read:
        cell_vectors = {key: data_read[key] for key in data_read.files}
    
    print("PREPROCESSED DATA IMPORTED.")
else:
    if not os.path.exists(new_folder_path):
        os.makedirs(new_folder_path)

    # 4. Extract cells and generate cell imgs. (img name e.g., 'frame_0_cell_1')
    unique_channels = info_df['Channel'].unique().tolist()
    channel_list = [1 if channel == option else 0 for option in unique_channels]

    cell_dict = extract_cells(imgs_path, masks_path, channel_list)

    x_train = np.array(list(cell_dict.values()))
    x_train = x_train.reshape(x_train.shape[0], 28, 28, 1)
    x_train, x_test = train_test_split(x_train, test_size=0.2, random_state=42)

    early_stop = EarlyStopping(monitor='val_loss', patience=5)

    # 5. Train autoencoder on the single cell images, save encoder model
    encoder = keras.models.Sequential([
        keras.layers.Flatten(input_shape=[28, 28]),
        keras.layers.Dense(100, activation="relu"),
        keras.layers.Dense(30, activation="relu"),
        ])
    decoder = keras.models.Sequential([
        keras.layers.Dense(100, activation="relu", input_shape=[30]),
        keras.layers.Dense(28 * 28, activation="sigmoid"),
        keras.layers.Reshape([28, 28])
        ])
    autoencoder = keras.models.Sequential([encoder, decoder])
    autoencoder.compile(loss="binary_crossentropy",
                    optimizer='adam')
    autoencoder.fit(x_train, x_train, epochs=100, validation_data=[x_test, x_test],
                    callbacks=[early_stop], verbose=0) 
    del x_train, x_test

    # 6. Get latent vectors and save to file
    cell_names = np.array(list(cell_dict.keys()))
    cell_images = np.stack(list(cell_dict.values()), axis=0)

    cell_vectors = encoder.predict(cell_images, verbose=0)
    cell_vectors = dict(zip(cell_names, cell_vectors))
    np.savez(vectors_path, **cell_vectors)
    encoder.save(encoder_path)
    del cell_dict, cell_images

    print("PREPROCESSING COMPLETE.")

### PART 2: Frame-by-frame Pairwise Cell Labeling##############################
print("INITIATING FRAME-BY-FRAME CELL IDENTIFICATION...")

# Initialize library for tracking lineages
lib = Library(masks[0], df)

for i, mask in tqdm(enumerate(masks[1:]), total=len(masks)-1,
                    desc="Processing Frames", unit="frame"):
    current_frame = i + 1
    temp_df = df[df['Frame'] == current_frame]

    scores = []
    for recent_cell in lib.all_recent():
        curr_mask = masks[current_frame]
        prev_mask = masks[recent_cell['frame']]

        key = f'frame_{recent_cell["frame"]}_cell_{recent_cell["cell_id"]}'
        recent_vec = cell_vectors[key]

        new_cells = np.unique(curr_mask)[1:]
        new_cells = new_cells[new_cells != 0]

        recent_cell_coords = np.array([recent_cell['x'], recent_cell['y']])
        new_cell_coords = (
            temp_df[temp_df['ROI'].isin(new_cells - 1)][['x', 'y']].to_numpy()
            )
        distances = cdist(recent_cell_coords.reshape(1, -1), new_cell_coords)[0]
        new_cells = new_cells[distances < search_radius]

        for new_cell in new_cells:
            if lib.is_recent_cell(current_frame, new_cell) == -1:
                x_new, y_new = (
                    temp_df[temp_df['ROI'] == (new_cell - 1)].iloc[0][['x', 'y']]
                    )
                
                iou_score = calculate_iou(recent_cell['cell_id'], prev_mask, 
                                        new_cell, mask)

                if iou_score > 0:
                    key = f'frame_{current_frame}_cell_{new_cell}'
                    new_vec = cell_vectors[key]
                    visual_score = cosine_similarity(recent_vec, new_vec)

                    distance = math.sqrt(
                        (x_new - recent_cell['x'])**2 +
                        (y_new - recent_cell['y'])**2
                        )

                    scores.append({
                        'next_cell_id': new_cell,
                        'next_cell_x': x_new,
                        'next_cell_y': y_new,
                        'lineage_id': recent_cell['lineage_id'],
                        'iou_score': iou_score,
                        'visual_score': visual_score,
                        'distance': distance
                        })
    lib.identify_cells(current_frame, scores)
lib.remove_short_lineages(10, len(masks))

print("CELL IDENTIFICATION COMPLETE.")

# TODO: add part 3 to file header comment
### PART 3: Preview and Export Results#########################################

results = lib.to_dataframe()
results = results.rename(columns={'cell_id':'ROI', 'lineage_id':'Label'})
results['ROI'] -= 1

final_df = info_df.merge(results, on=['ROI', 'Frame'], how='left')

# from pandasgui import show
# show(final_df)